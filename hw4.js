'number' + 3 + 3 // number33 - конкатенація

null + 3 // 3 - порожній об*єкт+3=3

5 && "qwerty" // qwerty - && повертає останнє значення якщо всі значення true

+'40' + +'2' + "hillel"; // 42hillel - унарний + привів 40 та 2 до числа, та конкатенація

'10' - 5 === 6; // false - стрінга перетворюється в намбер. Хоча 5 і 6 мають один тип, але різні значення то буде false

true + false // 1 - true це 1, false це 0

'4px' - 3 // NaN - стрінгу не можливо привести до числа

'4' - 3 // 1 - стрінга приведеться до числа 4

'6' + 3 ** 0; // 61 - в степені вищий пріорітет, 3 в степені 0 буде 1. Конкатенація

12 / '6' // 2 - стрінга перетворюється в число 6

'10' + (5 === 6); // 10false - спочатку розкриваємо дужки, а потім конкатенація

null == '' // false - null обробляється особливим чином оператором рівності, тоді як пусте значення це false. Тому null == 0; буде false, а null >= 0; буде true

3 ** (9 / 3); // 27 - спочатку відкриваємо дужки, буде 3, а далі підносимо 3 до степені3

!!'false' == !!'true' // true - подвійне логічне не, заперечує, а потім заперечує перше заперечення. Обидві стрінги є не пусті, тому буде true

0 || '0' && 1 // 1 - у оператора "і" виший приорітет, вираз '0' && 1 правильний, повернеться 1. У випадку оператора "або" у виразі 0 або 1, повернеться перше true

(+null == false) < 1; // false - відкрили дужки, + привів Null до числа 0,в дужках вийде true, відповідно 1 не більше 1

false && true || true // true - у оператора "і" вищий приоіртет, тому у виразі false && true повернеться пперше невірне false. Оператор "або" поверне перше правдиве значення

false && (false || true); // true - спочтаку відкриваємо дужки, опертор "або" поверне перше true, потім оператор "і" поверне перше false

(+null == false) < 1 ** 5; // false - спочатку дужки, + приведе null до 0, у душках буде true. Далі по пріорітету ступінь, буде 1. У виразі true < 1 буде false так як 1 не більше 1